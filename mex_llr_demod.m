%LLR_DEMOD  LLR Demodulator
% H = LLR_DEMOD_MEX(CONSTELLATION, MAPPING, METHOD) constructs 
% a LLR demodulator object H for a given constellation, mapping and noise 
% variance. The vectors CONSTELLATION and MAPPING are usually generated by 
% using MATLAB Modem Modulation Modem.<Type> and contain the complex or 
% real constellations points and the bit mapping, but in generall any signal
% constellation and any bit-mapping can be used. METHOD determines whether
% the exact LLR values or the approximations are calculated. (for more information:
% http://www.mathworks.com/help/toolbox/comm/ug/bqwswmc-1.html)
%
% A LLR demodulator object is equipped with one function:
%   - CALC_LLR (type "help llr_demod/calc_llr" for detailed help)
%
% Input: CONSTELLATION [1xM]
%        MAPPING [1xM]
%        Method ['exact', 'approx'] 
%
% Output: H [1x1]
%
% Version 1.5
% Author: Bernhard Schmidt
%
% Copyright 2011 by Bernhard Schmidt
% Permission is granted to use this program/data for educational/research only

classdef mex_llr_demod
    properties (SetAccess = private)
        constellation
        mapping
        method
    end
    properties (SetAccess = private, GetAccess = private)
        M
        mod_idx
        switch_bpsk
        sgn
        sigma_a2
    end
    methods
        function obj = mex_llr_demod(constellation,mapping,method)
            if ~isvector(constellation)
                error('CONSTELLATION must be a vector')
            end
            if ~isvector(mapping)
                error('Mapping must be a vector')
            end
            if ischar(method)
                if (~strcmp(method,'approx') && ~strcmp(method,'exact'))
                    error('Invalid method')
                else
                    obj.method = method;
                end
            end
            constellation = constellation(:).'; % row vector 
            mapping = mapping(:).';
            if isreal(constellation + 0) % hack for Matlab bug
            obj.constellation = real(constellation);
            else
                obj.constellation = constellation;
            end
            obj.mapping = mapping;
            obj.M = length(constellation);
            obj.mod_idx = log2(length(constellation));
            obj.switch_bpsk = 0;
            if obj.M == 2
                if isreal(obj.constellation)
                    if ~mean(obj.constellation)
                        obj.sgn = sign(obj.constellation(obj.mapping == 0));
                        obj.sigma_a2 = sum(abs((constellation - mean(constellation))).^2/length(constellation));
                        obj.switch_bpsk = 1;
                    end
                end
            end
        end
        function llr = calc_llr(obj, r, sigma_n2)
            %CALC_LLR LLR-Value Computation
            % LLR = CALC_LLR(H, R, NOISE_VAR) calculates the LLR-values LLR based on the received signal R.
            % and the noise variance NOISE_VAR. Demapping can be done for a constant noise variance and for
            % a variable noise variance which changes from symbol to symbol. For constant noise variance 
            % NOISE_VAR must be scalar and for variable noise variance NOISE_VAR must be a vector. 
            %
            % H must be a LLR_DEMOD object.
            %
            % Input: H [1x1]
            %        R [Nx1]
            %        NOISE_VAR [1x1] or [Nx1]
            % Output: LLR [log2(M)*Nx1]
            %
            % Author: Bernhard Schmidt
            %
            % Copyright 2011 by Bernhard Schmidt 
            % Permission is granted to use this program/data for educational/research only
            
            r_len = length(r);
            if ~isscalar(sigma_n2)
                if r_len~= length(sigma_n2)
                    error('NOISE_VAR must be scalar or it must be a vector with the same length as the received signal vector R!')
                end
            end
            if ~obj.switch_bpsk
                llr = calc_llr(r,sigma_n2,obj.constellation,obj.mapping);
            else
                llr = 4.*obj.sgn.*obj.sigma_a2./sigma_n2 .*real(r);
                llr = llr(:);
            end
        end
    end
end